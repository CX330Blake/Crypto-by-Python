# Crypto_Notebook
>[TOC]

## Classical Cryptography
古典密碼是指在計算機出現之前廣泛使用的密碼學技術。這些密碼技術通常基於簡單的替換或置換規則，而不涉及覆雜的數學運算。以下是幾種常見的古典密碼

- **凱撒密碼（Caesar Cipher）**：
    
    凱撒密碼是一種簡單的替換密碼，通過將字母表中的每個字母向後（或向前）移動固定數量的位置來加密文本。例如，如果向後移動3個位置，則"A"加密為"D"，"B"加密為"E"，以此類推。
    [凱薩密碼詳細介紹及實作](Classical\Caeser.ipynb)
    
- **替換密碼（Substitution Cipher）**：

    替換密碼將明文中的每個字母替換為另一個字母或符號。最常見的替換密碼是單表替換密碼，如凱撒密碼，而覆雜一些的替換密碼包括多表替換密碼，如多表凱撒密碼和維吉尼亞密碼。
    [替換密碼詳細介紹及實作](Classical\Substitution.ipynb)

- **置換密碼（Transposition Cipher）**：
  
    置換密碼重新排列明文中的字母，而不改變字母本身。例如，列置換密碼將明文中的字母按列排列，然後按特定規則讀取以生成密文。


- **維吉尼亞密碼（Vigenère Cipher）**：
  
    維吉尼亞密碼是一種多表替換密碼，它使用關鍵字來改變每個字母的替換規則。加密時，將明文的每個字母與關鍵字中的對應字母相結合來確定替換規則。


- **柵欄密碼（Rail Fence Cipher）**：
  
    柵欄密碼將明文中的字母沿著特定的線排列，然後以不同的方式讀取以生成密文。例如，3欄柵欄密碼將字母交替排列成三行，然後以從上到下、從左到右的順序讀取。

儘管這些古典密碼在過去被廣泛使用，但它們都存在易受攻擊的缺陷，因此在現代密碼學中已經不再安全。現代密碼學使用基於覆雜數學運算和密鑰管理的加密算法來確保更高的安全性。

## Encoding
當我們談論編碼（encode）和解碼（decode）時，我們通常是在討論將數據從一種形式轉換為另一種形式的過程。

- **編碼（Encode）**：編碼是將數據從一種形式轉換為另一種形式的過程。在編碼過程中，我們將數據轉換為特定格式或編碼方式，以便於傳輸、存儲或處理。例如，將文本字符串編碼為 UTF-8 格式、將圖像編碼為 Base64 格式等。     
- **解碼（Decode）**：解碼是將編碼後的數據重新轉換回原始形式的過程。在解碼過程中，我們將已編碼的數據重新轉換為原始格式，以便於讀取、顯示或進一步處理。例如，將 Base64 編碼的字符串解碼為原始圖像數據、將 JSON 格式的數據解碼為 Python 字典等。
    [Base64 原理及實作](Encoding\Base64.ipynb)


編碼和解碼的過程通常是成對出現的，即對同一份數據進行編碼和解碼。這種成對的過程可以確保數據在轉換過程中不會丟失或損壞，並能夠準確地還原回原始形式。

在計算機編程中，編碼和解碼經常用於處理數據的傳輸、存儲和處理，尤其是在不同系統或應用程序之間進行數據交換時。常見的編碼和解碼方式包括文本編碼（如UTF-8、ASCII）、圖像編碼（如Base64）、音頻編碼（如MP3）、視頻編碼（如H.264）等。

總之，編碼和解碼是將數據從一種形式轉換為另一種形式的重要過程，它們在計算機編程和數據處理中起著關鍵作用。

## Hash Funcitons

## Public Key Cryptography
### RSA
1. 選擇兩個大質數p和q，計算它們的乘積 $n = p \times q$。這是 RSA 的模數。選擇的質數應該足夠大，以防止通過分解 n 來破解 RSA 加密。
2. 計算 n 的歐拉函數 $φ(n) = (p-1) \times (q-1)$。φ(n) 是 n 以下與 n 互質的正整數的個數。
3. 選擇一個與 φ(n) 互質的整數 e，稱為加密指數。通常選擇一個較小的質數，如 65537。
4. 使用 e 和 n 構建公鑰 (e, n)。公鑰將被公開，用於加密數據。
5. 計算 e 的模反元素 d，即 $d \equiv e^{-1} \mod φ(n)$。d 稱為私鑰指數。
6. 使用 d 和 n 構建私鑰 (d, n)。私鑰應該保密，只有擁有私鑰的人可以解密數據。
7. 加密過程:
    - 將明文轉換為整數表示。可以使用 ASCII 編碼，每個字符對應一個數字。
    - 對每個整數 m，計算密文 $c = m^e \mod n$。
    - 將所有密文組成的列表作為加密後的消息。
8. 解密過程:
    - 對於每個密文 c，計算明文 $m = c^d \mod n$。

## Symmetric Key Algorithms